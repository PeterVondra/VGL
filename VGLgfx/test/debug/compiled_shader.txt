#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable



layout(binding = 2)uniform sampler2D albedoMap;
layout(binding = 3)uniform sampler2D roughnessMap;
layout(binding = 4)uniform sampler2D normalMap;





layout(location = 0)in float in_Depth;
layout(location = 1)in vec2 in_UV;
layout(location = 2)in vec3 in_Normal;
layout(location = 3)in vec3 in_FragPosition;
layout(location = 4)in vec3 in_ViewPosition;


layout(location = 5)in mat3 in_TBN;


layout(location = 0)out vec4 out_Position;
layout(location = 1)out vec4 out_Normal;
layout(location = 2)out vec4 out_Albedo;

layout(location = 3)out vec4 out_MRAA;


layout(binding = 1)uniform UniformBufferObject
{
 vec4 albedo;
 vec4 mrao;
 float pdmDepth;
 float lumaThreshold;
} ubo;






float checker(vec2 uv, float repeats)
{
  float cx = floor(repeats * uv . x);
  float cy = floor(repeats * uv . y);
  float result = mod(cx + cy, 2.0);
  return sign(result);
}

float linearDepth(float depth)
{

 return(1.0f * 1000.0f)/(1000.0f + 1.0f - depth *(1000.0f - 1.0f));
}

void main()
{



 vec2 uv = in_UV;



 out_Albedo = texture(albedoMap, uv);
 if(out_Albedo . a < 0.5)
  discard;




 if(isinf(out_Albedo . r)|| isinf(out_Albedo . g)|| isinf(out_Albedo . b)|| isnan(out_Albedo . r)|| isnan(out_Albedo . g)|| isnan(out_Albedo . b)){ out_Albedo = vec4(0.0f, 0.0f, 0.0f, 1.0f);}

 out_Position = vec4(in_FragPosition, 1.0f);


 out_Normal = vec4(normalize(in_TBN *(normalize(texture(normalMap, uv). rgb * 2.0f - 1.0f))), 1.0f);







 out_MRAA . r = ubo . mrao . r;



 out_MRAA . g = texture(roughnessMap, uv). r * ubo . mrao . g;







 out_MRAA . b = ubo . mrao . b;


 out_MRAA . a = in_Depth;
}
